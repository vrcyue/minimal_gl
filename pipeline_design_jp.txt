現状把握
- src/graphics.cpp:28 と :129 に固定長の MRT／Compute 用テクスチャ配列があり、ダブルバッファと用途がコードに埋め込まれている。
- GraphicsDispatchCompute（src/graphics.cpp:1452）は単一のコンピュートパスのみを扱い、前フレームの ComputeRT を読み込みつつ現フレームを書き込む固定フローになっている。
- GraphicsDrawFullScreenQuad（src/graphics.cpp:709）は 1 度のフラグメント描画で G-Buffer/MRT の生成と ComputeRT サンプリリングを同時に行う設計。
- GraphicsUpdate（src/graphics.cpp:1595）のレンダリング順序が「Compute → Fullscreen Quad」に固定され、スクリーンショット系関数（src/graphics.cpp:1035, 1399）も同じ並びを前提にしている。
- エクスポート後のランタイム（src/resource/main.cpp:422-656）も同じ制御フローを持つため、修正はエディタと同時対応が必須。

課題（目標との差分）
- パス順序がコードに埋め込まれているため、フラグメント → Compute → フラグメントのような任意並びを表現できない。
- テクスチャは匿名の配列管理であり、どのパスが参照／書き込みするか、履歴を何フレーム保持するか等を記述できない。
- パス間のバリア指定が暗黙的で、並びを変えるたびに必要な glMemoryBarrier 更新を手作業で行う必要がある。
- UI／プロジェクト保存（src/app.cpp:1562, 1793）は「1 フラグメント + 任意で 1 Compute」という前提、エクスポート済みプロジェクトも同じ想定に依存。

提案アーキテクチャ
- RenderSettings と並列に PipelineDescription（リソース定義とパス定義）を導入。
  - PipelineResource: ID、フォーマット、解像度、履歴長、フィルタ設定、GL ハンドル配列などを保持。
  - PipelinePass: 種別（Fragment/Compute）、プログラム ID、入出力リソースとアクセスモード（サンプル／Image 読み／Image 書き／履歴参照）、クリア指示などを保持。
- グローバル配列をリソーステーブルへ置き換え、AcquireTexture(resource, frameOffset, usage) のようなヘルパで実際の GLuint を取得。履歴長 historyLength を 1（単発）、2（Ping-Pong）、N（将来拡張）に対応。
- GraphicsUpdate をパス列でループ処理するフレームグラフへ改修。
  - フラグメントパス: 宣言された出力を FBO に組み立て、入力を所定テクスチャユニットへバインド、共通ユニフォームを設定してフルスクリーンクアッド描画。
  - コンピュートパス: 入出力を glBindImageTexture でバインドし、リソース解像度からディスパッチサイズを算出（必要なら override）、glDispatchCompute を実行。
  - 各パス後に IO 情報に基づくバリアを一括設定するヘルパを呼び出し、順序変更にも強い設計にする。
- 「デフォルト FBO へのブリット」を仮想パスとして扱い、スクリーンショット／キャプチャ API も同一パイプラインを再利用可能とする。
- パイプライン定義をアプリ層で編集可能にし、各パスへシェーダファイルを割り当てて JSON 保存／読み込み。エクスポート時には同じパイプライン記述を C++ コードへ出力。
- エクスポート実行ファイル（src/resource/main.cpp）にも同じリソース／パス表を埋め込み、エディタと同一のインタプリタで描画。

移行ステップ
1. PipelineDescription のメモリ構造と JSON 形式を設計し、「フラグメントで G-Buffer → Compute でエフェクト → フラグメントで最終合成」が記述できるか検証。
2. エディタ側でフレームグラフインタプリタを試験実装し、既存の「Compute → フラグメント」シーケンスも新モデルで再現できることを確認。
3. ランタイム／エクスポーター／UI に段階的に反映し、ホットリロードやエクスポート済み実行ファイルでも同じパイプライン定義が機能するよう調整。
4. サンプル GLSL とドキュメントを更新し、新しいバインディング方針とマルチパス構成例を提示。
